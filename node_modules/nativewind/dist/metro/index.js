"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withNativeWind = void 0;
const connect_1 = __importDefault(require("connect"));
const loadConfig_1 = __importDefault(require("tailwindcss/loadConfig"));
const package_json_1 = __importDefault(require("tailwindcss/package.json"));
const micromatch_1 = __importDefault(require("micromatch"));
const path_1 = __importDefault(require("path"));
const metro_1 = require("react-native-css-interop/metro");
const common_1 = require("./common");
const tailwind_cli_1 = require("./tailwind-cli");
const cliPromises = {};
const outputCSS = {};
function withNativeWind(metroConfig, { input, outputDir = ["node_modules", ".cache", "nativewind"].join(path_1.default.sep), projectRoot = process.cwd(), inlineRem = 14, configPath: tailwindConfigPath = "tailwind.config.js", cliCommand = `node ${path_1.default.join(require.resolve("tailwindcss/package.json"), "../", package_json_1.default.bin.tailwindcss)}`, browserslist = "last 1 version", browserslistEnv = "native", } = {}) {
    if (!input) {
        throw new Error("withNativeWind requires an input parameter: `withNativeWind(config, { input: <css-file> })`");
    }
    input = path_1.default.resolve(input);
    const output = path_1.default.resolve(projectRoot, path_1.default.join(outputDir, path_1.default.basename(input)));
    const { important } = getTailwindConfig(tailwindConfigPath, output);
    function startCli(platform, hot, dev) {
        cliPromises[platform] ||= (0, tailwind_cli_1.tailwindCli)(input, metroConfig, {
            dev,
            hot,
            platform,
            projectRoot,
            input,
            output: `${output}.${platform}.css`,
            cliCommand,
            browserslist,
            browserslistEnv,
        }).then((css) => {
            if (css) {
                outputCSS[platform] = css;
            }
            return css;
        });
        return cliPromises[platform];
    }
    metroConfig = (0, metro_1.withCssInterop)(metroConfig, {
        ...common_1.cssToReactNativeRuntimeOptions,
        inlineRem,
        selectorPrefix: typeof important === "string" ? important : undefined,
    });
    const enhanceMiddleware = metroConfig.server.enhanceMiddleware;
    const getTransformOptions = metroConfig.transformer.getTransformOptions;
    metroConfig.transformerPath = require.resolve("./transformer");
    metroConfig.server = {
        ...metroConfig.server,
        enhanceMiddleware(middleware, metroServer) {
            let server = (0, connect_1.default)()
                .use(...metro_1.middleware)
                .use("/", async (req, _res, next) => {
                const url = new URL(req.url, "http://localhost");
                const platform = url.searchParams.get("platform");
                if (platform) {
                    try {
                        await startCli(platform, url.searchParams.get("dev") !== "false", url.searchParams.get("hot") !== "true");
                    }
                    catch (error) {
                        return next(error);
                    }
                }
                next();
            });
            if (enhanceMiddleware) {
                server = server.use(enhanceMiddleware(middleware, metroServer));
            }
            return server;
        },
    };
    metroConfig.transformer = {
        ...metroConfig.transformer,
        async getTransformOptions(entryPoints, options, getDependenciesOf) {
            await startCli(options.platform, options.dev, options.hot);
            return getTransformOptions(entryPoints, options, getDependenciesOf);
        },
        nativewind: {
            input,
            output,
            css: outputCSS,
        },
    };
    return metroConfig;
}
exports.withNativeWind = withNativeWind;
function getTailwindConfig(tailwindConfigPath, output) {
    const config = (0, loadConfig_1.default)(path_1.default.resolve(tailwindConfigPath));
    const content = config.content;
    const contentArray = "files" in content ? content.files : content;
    const matchesOutputDir = contentArray.some((pattern) => {
        if (typeof pattern !== "string")
            return false;
        return micromatch_1.default.isMatch(output, pattern);
    });
    if (matchesOutputDir) {
        throw new Error(`NativeWind: Your '${tailwindConfigPath}#content' includes the output file ${output} which will cause an infinite loop. Please read https://tailwindcss.com/docs/content-configuration#styles-rebuild-in-an-infinite-loop`);
    }
    return config;
}
//# sourceMappingURL=index.js.map