"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSourcePolyFill = void 0;
var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
var EventSourcePolyFill = function (url, options) {
    var eventsource = this, interval = 500, lastEventId = null, lastIndexProcessed = 0, eventType;
    if (!url || typeof url != "string") {
        throw new SyntaxError("Not enough arguments");
    }
    this.URL = url;
    this.OPTIONS = options;
    this.readyState = this.CONNECTING;
    this._pollTimer = null;
    this._xhr = null;
    function pollAgain(interval) {
        eventsource._pollTimer = setTimeout(function () {
            poll.call(eventsource);
        }, interval);
    }
    function poll() {
        try {
            if (eventsource.readyState == eventsource.CLOSED)
                return;
            var xhr = new XMLHttpRequest();
            xhr.open(eventsource.OPTIONS.method || "GET", eventsource.URL, true);
            if (eventsource.OPTIONS && eventsource.OPTIONS.headers) {
                Object.keys(eventsource.OPTIONS.headers).forEach((key) => {
                    xhr.setRequestHeader(key, eventsource.OPTIONS.headers[key]);
                });
            }
            xhr.setRequestHeader("Accept", "text/event-stream");
            xhr.setRequestHeader("Cache-Control", "no-cache");
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            if (lastEventId != null)
                xhr.setRequestHeader("Last-Event-ID", lastEventId);
            lastIndexProcessed = 0;
            xhr.timeout =
                this.OPTIONS && this.OPTIONS.timeout !== undefined
                    ? this.OPTIONS.timeout
                    : 50000;
            console.log("noe?");
            xhr.onreadystatechange = function () {
                console.log("redy");
                if (this.readyState == 3 ||
                    (this.readyState == 4 && this.status == 200)) {
                    if (eventsource.readyState == eventsource.CONNECTING) {
                        eventsource.readyState = eventsource.OPEN;
                        eventsource.dispatchEvent("open", { type: "open" });
                    }
                    var responseText = "";
                    try {
                        responseText = this.responseText || "";
                    }
                    catch (e) { }
                    var parts = responseText.substr(lastIndexProcessed).split("\n"), data = [], i = 0, retry = 0, line = "";
                    lastIndexProcessed = responseText.lastIndexOf("\n\n") + 2;
                    for (; i < parts.length; i++) {
                        line = parts[i].replace(reTrim, "");
                        if (line.indexOf("event") == 0) {
                            eventType = line.replace(/event:?\s*/, "");
                        }
                        else if (line.indexOf("retry") == 0) {
                            retry = parseInt(line.replace(/retry:?\s*/, ""));
                            if (!isNaN(retry)) {
                                interval = retry;
                            }
                        }
                        else if (line.indexOf("data") == 0) {
                            data.push(line.replace(/data:?\s*/, ""));
                        }
                        else if (line.indexOf("id:") == 0) {
                            lastEventId = line.replace(/id:?\s*/, "");
                        }
                        else if (line.indexOf("id") == 0) {
                            lastEventId = null;
                        }
                        else if (line == "") {
                            if (data.length) {
                                var event = new MessageEvent(data.join("\n"), eventsource.url, lastEventId);
                                eventsource.dispatchEvent(eventType || "message", event);
                                data = [];
                                eventType = undefined;
                            }
                        }
                    }
                    if (this.readyState == 4)
                        pollAgain(interval);
                }
                else if (eventsource.readyState !== eventsource.CLOSED) {
                    if (this.readyState == 4) {
                        pollAgain(interval);
                    }
                    else if (this.readyState == 0) {
                        pollAgain(interval);
                    }
                }
            };
            xhr.onerror = function (e) {
                eventsource.readyState = eventsource.CONNECTING;
                eventsource.dispatchEvent("error", {
                    type: "error",
                    message: this.responseText,
                });
            };
            if (eventsource.OPTIONS.body) {
                xhr.send(eventsource.OPTIONS.body);
            }
            else {
                xhr.send();
            }
            if (xhr.timeout > 0) {
                setTimeout(function () {
                    if (true || xhr.readyState == 3)
                        xhr.abort();
                }, xhr.timeout);
            }
            eventsource._xhr = xhr;
        }
        catch (e) {
            eventsource.dispatchEvent("error", { type: "error", data: e.message });
        }
    }
    poll();
};
exports.EventSourcePolyFill = EventSourcePolyFill;
exports.EventSourcePolyFill.prototype = {
    close: function () {
        this.readyState = this.CLOSED;
        clearInterval(this._pollTimer);
        this._xhr.abort();
    },
    CONNECTING: 0,
    OPEN: 1,
    CLOSED: 2,
    dispatchEvent: function (type, event) {
        var handlers = this["_" + type + "Handlers"];
        if (handlers) {
            for (var i = 0; i < handlers.length; i++) {
                handlers[i].call(this, event);
            }
        }
        if (this["on" + type]) {
            this["on" + type].call(this, event);
        }
    },
    addEventListener: function (type, handler) {
        if (!this["_" + type + "Handlers"]) {
            this["_" + type + "Handlers"] = [];
        }
        this["_" + type + "Handlers"].push(handler);
    },
    removeEventListener: function (type, handler) {
        var handlers = this["_" + type + "Handlers"];
        if (!handlers) {
            return;
        }
        for (var i = handlers.length - 1; i >= 0; --i) {
            if (handlers[i] === handler) {
                handlers.splice(i, 1);
                break;
            }
        }
    },
    onerror: null,
    onmessage: null,
    onopen: null,
    readyState: 0,
    URL: "",
};
var MessageEvent = function (data, origin, lastEventId) {
    this.data = data;
    this.origin = origin;
    this.lastEventId = lastEventId || "";
};
MessageEvent.prototype = {
    data: null,
    type: "message",
    lastEventId: "",
    origin: "",
};
class RNEventSource {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.eventSource = new exports.EventSourcePolyFill(url, options);
        this.listeners = [];
    }
    addEventListener(type, listener) {
        this.eventSource.addEventListener(type, listener);
        const remove = () => {
            this.removeListener(type, listener);
        };
        this.listeners.push({
            remove: remove,
            type: type,
            listener: listener,
        });
        return this.listeners[this.listeners.length - 1];
    }
    removeAllListeners() {
        this.listeners.map((listener) => {
            listener.remove();
        });
    }
    removeListener(type, listener) {
        this.eventSource.removeEventListener(type, listener);
    }
    close() {
        this.eventSource.close();
    }
}
module.exports = RNEventSource;
//# sourceMappingURL=event-source.js.map