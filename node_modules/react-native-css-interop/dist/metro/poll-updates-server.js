"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendUpdate = exports.middleware = void 0;
const css_to_rn_1 = require("../css-to-rn");
const connections = new Set();
const last = {
    version: 0,
    data: undefined,
    json: undefined,
};
exports.middleware = [
    "/__css_interop_update_endpoint",
    (req, res) => {
        const version = parseInt(req.url?.split("?version=")[1] ?? "0");
        if (version && version < last.version) {
            res.write(`data: {"version":${last.version},"data":${last.json}}\n\n`);
            res.end();
            return;
        }
        connections.add(res);
        res.writeHead(200, {
            "Content-Type": "text/event-stream",
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
        });
        setTimeout(() => {
            res.end();
            connections.delete(res);
        }, 30000);
        req.on("close", () => connections.delete(res));
    },
];
function sendUpdate(data, version, config) {
    const newData = (0, css_to_rn_1.cssToReactNativeRuntime)(data, config);
    const newJson = JSON.stringify(newData);
    const dataToSend = last.data ? getDiff(newData, last.data) : newJson;
    last.version = version;
    last.data = newData;
    last.json = newJson;
    for (const connection of connections) {
        connection.write(`data: {"version":${last.version},"data":${dataToSend}}\n\n`);
        connection.end();
    }
}
exports.sendUpdate = sendUpdate;
function getDiff(current, previous) {
    return JSON.stringify({
        $$compiled: true,
        flags: current.flags,
        rem: current.rem,
        rootVariables: current.rootVariables,
        universalVariables: current.universalVariables,
        rules: current.rules?.filter((rule, index) => {
            const match = previous.rules?.find((r) => r[0] === rule[0]);
            return match ? !deepEqual(rule, match) : true;
        }),
        keyframes: current.keyframes?.filter((keyframe, index) => {
            const match = previous.keyframes?.find((r) => r[0] === keyframe[0]);
            return match ? !deepEqual(keyframe, match) : true;
        }),
    });
}
function deepEqual(obj1, obj2) {
    if (obj1 === obj2) {
        return true;
    }
    if (obj1 !== Object(obj1) && obj2 !== Object(obj2)) {
        return obj1 === obj2;
    }
    if (Object.keys(obj1).length !== Object.keys(obj2).length)
        return false;
    for (let key in obj1) {
        if (!(key in obj2))
            return false;
        if (!deepEqual(obj1[key], obj2[key]))
            return false;
    }
    return true;
}
//# sourceMappingURL=poll-updates-server.js.map