"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testCondition = exports.testContainerQuery = exports.testPseudoClasses = exports.testMediaQuery = exports.testMediaQueries = exports.testRule = void 0;
const globals_1 = require("./globals");
const react_native_1 = require("react-native");
const shared_1 = require("../../shared");
const observable_1 = require("../observable");
function testRule(state, rule, props) {
    if (rule.pseudoClasses && !testPseudoClasses(state, rule.pseudoClasses)) {
        return false;
    }
    if (rule.media && !testMediaQueries(state, rule.media)) {
        return false;
    }
    if (rule.containerQuery && !testContainerQuery(state, rule.containerQuery)) {
        return false;
    }
    if (rule.attrs && !testAttributes(props, rule.attrs)) {
        return false;
    }
    return true;
}
exports.testRule = testRule;
function testMediaQueries(state, mediaQueries) {
    return mediaQueries.every((query) => testMediaQuery(state, query));
}
exports.testMediaQueries = testMediaQueries;
function testMediaQuery(state, mediaQuery, conditionReference = {
    width: globals_1.vw,
    height: globals_1.vh,
}) {
    const pass = mediaQuery.mediaType !== "print" &&
        testCondition(state, mediaQuery.condition, conditionReference);
    return mediaQuery.qualifier === "not" ? !pass : pass;
}
exports.testMediaQuery = testMediaQuery;
function testPseudoClasses(propState, meta, interaction = propState.interaction) {
    let passed = true;
    if (meta.active) {
        interaction.active ??= (0, observable_1.observable)(false);
        passed = interaction.active.get(propState.declarationEffect) && passed;
    }
    if (meta.hover) {
        interaction.hover ??= (0, observable_1.observable)(false);
        passed = interaction.hover.get(propState.declarationEffect) && passed;
    }
    if (meta.focus) {
        interaction.focus ??= (0, observable_1.observable)(false);
        passed = interaction.focus.get(propState.declarationEffect) && passed;
    }
    return passed;
}
exports.testPseudoClasses = testPseudoClasses;
function testContainerQuery(state, containerQuery) {
    if (!containerQuery || containerQuery.length === 0) {
        return true;
    }
    return containerQuery.every((query) => {
        let container;
        if (query.name) {
            container = state.refs.containers[query.name];
            if (!container)
                return false;
        }
        if (!container)
            container = state.refs.containers[shared_1.DEFAULT_CONTAINER_NAME];
        if (!container)
            return false;
        if (query.pseudoClasses &&
            !testPseudoClasses(state, query.pseudoClasses, container.interaction)) {
            return false;
        }
        if (query.attrs && !testAttributes(container.refs.props, query.attrs)) {
            return false;
        }
        if (!query.condition)
            return true;
        const layout = container.interaction.layout.get(state.declarationEffect);
        return testCondition(state, query.condition, {
            width: layout[0],
            height: layout[1],
        });
    });
}
exports.testContainerQuery = testContainerQuery;
function testCondition(state, condition, conditionReference) {
    if (!condition)
        return true;
    if (condition.type === "operation") {
        if (condition.operator === "and") {
            return condition.conditions.every((c) => {
                return testCondition(state, c, conditionReference);
            });
        }
        else {
            return condition.conditions.some((c) => {
                return testCondition(state, c, conditionReference);
            });
        }
    }
    else if (condition.type === "not") {
        return !testCondition(state, condition.value, conditionReference);
    }
    else if (condition.type === "style") {
        return false;
    }
    return testFeature(state, condition.value, conditionReference);
}
exports.testCondition = testCondition;
function testFeature(state, feature, conditionReference) {
    switch (feature.type) {
        case "plain":
            return testPlainFeature(state, feature, conditionReference);
        case "range":
            return testRange(state, feature, conditionReference);
        case "boolean":
            return testBoolean(state, feature);
        case "interval":
            return false;
        default:
            feature;
    }
    return false;
}
function testPlainFeature(state, feature, ref) {
    const value = getMediaFeatureValue(state, feature.value);
    if (value === null) {
        return false;
    }
    switch (feature.name) {
        case "display-mode":
            return value === "native" || react_native_1.Platform.OS === value;
        case "prefers-color-scheme":
            return globals_1.colorScheme.get(state.declarationEffect) === value;
        case "width":
            return testComparison(state, "equal", ref.width, value);
        case "min-width":
            return testComparison(state, "greater-than-equal", ref.width, value);
        case "max-width":
            return testComparison(state, "less-than-equal", ref.width, value);
        case "height":
            return testComparison(state, "equal", ref.height, value);
        case "min-height":
            return testComparison(state, "greater-than-equal", ref.height, value);
        case "max-height":
            return testComparison(state, "less-than-equal", ref.height, value);
        case "orientation":
            switch (value) {
                case "landscape":
                    return testComparison(state, "less-than", ref.height, ref.width);
                case "portrait":
                    return testComparison(state, "greater-than-equal", ref.height, ref.width);
            }
        default:
            return false;
    }
}
function getMediaFeatureValue(state, value) {
    if (value.type === "number") {
        return value.value;
    }
    else if (value.type === "length") {
        if (value.value.type === "value") {
            const length = value.value.value;
            switch (length.unit) {
                case "px":
                    return length.value;
                case "rem":
                    return length.value * globals_1.rem.get(state.declarationEffect);
                default:
                    return null;
            }
        }
        else {
            return null;
        }
    }
    else if (value.type === "ident") {
        return value.value;
    }
    return null;
}
function testRange(state, feature, ref) {
    const value = getMediaFeatureValue(state, feature.value);
    if (value === null || typeof value !== "number") {
        return false;
    }
    switch (feature.name) {
        case "height":
            return testComparison(state, feature.operator, ref.height, value);
        case "width":
            return testComparison(state, feature.operator, ref.width, value);
        default:
            return false;
    }
}
function testComparison(state, comparison, ref, value) {
    ref = unwrap(state.declarationEffect, ref);
    value = unwrap(state.declarationEffect, value);
    if (typeof value !== "number")
        return false;
    switch (comparison) {
        case "equal":
            return ref === value;
        case "greater-than":
            return ref > value;
        case "greater-than-equal":
            return ref >= value;
        case "less-than":
            return ref < value;
        case "less-than-equal":
            return ref < value;
    }
}
function testBoolean(state, feature) {
    switch (feature.name) {
        case "prefers-reduced-motion":
            return globals_1.isReduceMotionEnabled.get(state.declarationEffect);
        case "ltr":
            return react_native_1.I18nManager.isRTL === false;
        case "rtl":
            return react_native_1.I18nManager.isRTL;
    }
    return false;
}
function unwrap(effect, value) {
    return value && typeof value === "object" && "get" in value
        ? value.get(effect)
        : value;
}
function testAttributes(props, conditions) {
    if (!props)
        return false;
    for (const condition of conditions) {
        const attrValue = condition.type === "data-attribute"
            ? props?.["dataSet"]?.[condition.name]
            : props?.[condition.name];
        if (!testAttribute(attrValue, condition)) {
            return false;
        }
    }
    return true;
}
function testAttribute(propValue, condition) {
    const operation = condition.operation;
    if (operation == null)
        return propValue != null;
    switch (operation.operator) {
        case "empty": {
            return propValue == null || propValue == "";
        }
        case "truthy": {
            return Boolean(propValue);
        }
        case "dash-match":
        case "prefix":
        case "substring":
        case "suffix":
            return false;
        case "includes":
            return propValue?.toString().includes(operation.value);
        case "equal": {
            return propValue?.toString() == operation.value;
        }
    }
}
//# sourceMappingURL=conditions.js.map