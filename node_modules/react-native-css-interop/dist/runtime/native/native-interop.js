"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.specificityCompare = exports.interop = void 0;
const react_1 = require("react");
const observable_1 = require("../observable");
const globals_1 = require("./globals");
const utils_1 = require("./utils");
const style_store_1 = require("./style-store");
const render_component_1 = require("./render-component");
const conditions_1 = require("./conditions");
const shared_1 = require("../../shared");
function interop(component, configs, props, ref) {
    let variables = (0, react_1.useContext)(globals_1.variableContext);
    let containers = (0, react_1.useContext)(globals_1.containerContext);
    const [componentState, setState] = (0, react_1.useState)(() => {
        const componentState = {
            refs: { props, containers, variables },
            interaction: {},
            upgrades: {},
            propStates: [],
            rerender: () => setState((state) => ({ ...state })),
        };
        componentState.propStates = configs.map((config) => {
            return createPropState(componentState, config);
        });
        return componentState;
    });
    (0, react_1.useEffect)(() => {
        return () => {
            for (const prop of componentState.propStates) {
                (0, observable_1.cleanupEffect)(prop.declarationEffect);
                (0, observable_1.cleanupEffect)(prop.styleEffect);
                if (prop.sharedValues?.size) {
                    const { cancelAnimation } = require("react-native-reanimated");
                    for (const value of prop.sharedValues.values()) {
                        cancelAnimation(value);
                    }
                }
            }
        };
    }, [componentState.propStates]);
    componentState.refs.props = props;
    componentState.refs.containers = containers;
    componentState.refs.variables = variables;
    props = Object.assign({ ref }, props);
    for (const propState of componentState.propStates) {
        propState.declarationEffect.rerun(true);
        Object.assign(props, propState.props);
        if (propState.target !== propState.source) {
            delete props[propState.source];
        }
        if (propState.variables) {
            variables = Object.assign({}, variables, propState.variables);
        }
        if (propState.containerNames) {
            containers = Object.assign({}, containers);
            for (const name of propState.containerNames) {
                containers[name] = componentState;
            }
            containers[shared_1.DEFAULT_CONTAINER_NAME] = componentState;
        }
    }
    return (0, render_component_1.renderComponent)(component, componentState, props, variables, containers);
}
exports.interop = interop;
function createPropState(componentState, config) {
    const propState = {
        source: config.source,
        target: config.target,
        nativeStyleToProp: config.nativeStyleToProp,
        upgrades: componentState.upgrades,
        interaction: componentState.interaction,
        refs: componentState.refs,
        testID: componentState.refs.props?.testID,
        tracking: {
            index: 0,
            rules: [],
            changed: false,
        },
        declarationEffect: {
            dependencies: new Set(),
            rerun(isRendering = false) {
                (0, observable_1.cleanupEffect)(propState.declarationEffect);
                const tracking = propState.tracking;
                const classNames = propState.refs.props?.[propState.source];
                const inlineStyles = propState.refs.props?.[config.target];
                tracking.index = 0;
                tracking.changed = tracking.inlineStyles !== inlineStyles;
                tracking.inlineStyles = inlineStyles;
                const normal = [];
                const important = [];
                if (typeof classNames === "string") {
                    for (const className of classNames.split(/\s+/)) {
                        addStyle(propState, className, normal, important);
                        globals_1.externalCallbackRef.current?.(className);
                    }
                }
                tracking.changed ||=
                    tracking.rules.length !== normal.length + important.length;
                if (!tracking.changed)
                    return false;
                normal.sort(specificityCompare);
                important.sort(specificityCompare);
                if (Array.isArray(inlineStyles)) {
                    const flat = inlineStyles.flat(10).sort(specificityCompare);
                    for (const style of flat) {
                        addStyle(propState, style, normal, important);
                    }
                }
                else if (inlineStyles) {
                    addStyle(propState, inlineStyles, normal, important);
                }
                propState.declarations = [];
                propState.importantDeclarations = [];
                propState.animation = undefined;
                propState.transition = undefined;
                propState.variables = undefined;
                propState.containerNames = undefined;
                addDeclarations(propState, normal, propState.declarations);
                addDeclarations(propState, important, propState.importantDeclarations);
                propState.styleEffect.rerun(isRendering);
                return tracking.changed;
            },
        },
        styleEffect: {
            dependencies: new Set(),
            rerun(isRendering = false) {
                (0, observable_1.cleanupEffect)(propState.styleEffect);
                const props = {};
                const normalizedProps = {};
                const delayedValues = [];
                const seenAnimatedProps = new Set();
                (0, utils_1.processDeclarations)(propState, propState.declarations, props, normalizedProps, delayedValues);
                (0, utils_1.processAnimations)(props, normalizedProps, seenAnimatedProps, propState);
                (0, utils_1.processDeclarations)(propState, propState.importantDeclarations, props, normalizedProps, delayedValues);
                for (const delayed of delayedValues) {
                    delayed();
                }
                (0, utils_1.processTransition)(props, normalizedProps, seenAnimatedProps, propState);
                (0, utils_1.retainSharedValues)(props, normalizedProps, seenAnimatedProps, propState);
                (0, utils_1.nativeStyleToProp)(props, config);
                if (!isRendering) {
                    componentState.rerender();
                }
                propState.props = props;
            },
        },
    };
    return propState;
}
function addStyle(propState, style, normal, important) {
    const ruleSet = typeof style === "string"
        ? style_store_1.globalStyles.get(style)?.get(propState.declarationEffect)
        : style_store_1.opaqueStyles.has(style)
            ? style_store_1.opaqueStyles.get(style)
            : style;
    if (!ruleSet) {
        if (typeof style === "string") {
            const styleObservable = (0, observable_1.observable)({ $$type: "StyleRuleSet" }, { name: style });
            styleObservable.get(propState.declarationEffect);
            style_store_1.globalStyles.set(style, styleObservable);
        }
        return;
    }
    if (!("$$type" in ruleSet)) {
        normal.push(ruleSet);
        return;
    }
    const upgrades = propState.upgrades;
    if (ruleSet.animation)
        upgrades.animated ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
    if (ruleSet.variables)
        upgrades.variables ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
    if (ruleSet.container)
        upgrades.containers ||= render_component_1.UpgradeState.SHOULD_UPGRADE;
    const tracking = propState.tracking;
    if (ruleSet.normal) {
        for (const rule of ruleSet.normal) {
            if ((0, conditions_1.testRule)(propState, rule, propState.refs.props)) {
                normal.push(rule);
                tracking.index++;
                tracking.changed ||= tracking.rules[tracking.index] !== rule;
                tracking.rules[tracking.index] = rule;
            }
        }
    }
    if (ruleSet.important) {
        for (const rule of ruleSet.important) {
            if ((0, conditions_1.testRule)(propState, rule, propState.refs.props)) {
                important.push(rule);
                tracking.index++;
                tracking.changed ||= tracking.rules[tracking.index] !== rule;
                tracking.rules[tracking.index] = rule;
            }
        }
    }
}
function addDeclarations(propState, rules, target) {
    for (const rule of rules) {
        if ("$$type" in rule) {
            if (rule.animations) {
                propState.animation ??= { ...defaultAnimation, waitingLayout: false };
                Object.assign(propState.animation, rule.animations);
            }
            if (rule.transition) {
                propState.transition ??= { ...defaultTransition };
                Object.assign(propState.transition, rule.transition);
            }
            if (rule.variables) {
                propState.variables ??= {};
                for (const variable of rule.variables) {
                    propState.variables[variable[0]] = variable[1];
                }
            }
            if (rule.container) {
                propState.containerNames = rule.container.names;
            }
            if (rule.declarations) {
                target.push(...rule.declarations);
            }
        }
        else {
            target.push(rule);
        }
    }
}
function specificityCompare(o1, o2) {
    if (!o1)
        return -1;
    if (!o2)
        return 1;
    const a = "specificity" in o1 ? o1.specificity : inlineSpecificity;
    const b = "specificity" in o2 ? o2.specificity : inlineSpecificity;
    if (a.I && b.I && a.I !== b.I) {
        return a.I - b.I;
    }
    else if (a.inline && b.inline && a.inline !== b.inline) {
        return a.inline ? 1 : -1;
    }
    else if (a.A && b.A && a.A !== b.A) {
        return a.A - b.A;
    }
    else if (a.B && b.B && a.B !== b.B) {
        return a.B - b.B;
    }
    else if (a.C && b.C && a.C !== b.C) {
        return a.C - b.C;
    }
    else if (a.S && b.S && a.S !== b.S) {
        return a.S - b.S;
    }
    else if (a.O && b.O && a.O !== b.O) {
        return a.O - b.O;
    }
    else {
        return 0;
    }
}
exports.specificityCompare = specificityCompare;
const inlineSpecificity = { inline: 1 };
const defaultAnimation = {
    name: [],
    direction: ["normal"],
    fillMode: ["none"],
    iterationCount: [{ type: "number", value: 1 }],
    timingFunction: [{ type: "linear" }],
    playState: ["running"],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
};
const defaultTransition = {
    property: [],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
    timingFunction: [{ type: "linear" }],
};
//# sourceMappingURL=native-interop.js.map