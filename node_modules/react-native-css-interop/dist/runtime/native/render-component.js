"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderComponent = exports.UpgradeState = void 0;
const react_1 = require("react");
const react_native_1 = require("react-native");
const globals_1 = require("./globals");
const observable_1 = require("../observable");
const utils_1 = require("./utils");
const animatedCache = new Map();
exports.UpgradeState = {
    NONE: 0,
    SHOULD_UPGRADE: 1,
    UPGRADED: 2,
    WARNED: 3,
};
function renderComponent(baseComponent, state, props, variables, containers) {
    let component = baseComponent;
    const shouldWarn = state.upgrades.canWarn;
    const isContainer = state.upgrades.containers;
    if (state.interaction.active || isContainer) {
        state.interaction.active ??= (0, observable_1.observable)(false);
        props.onPressIn = (event) => {
            state.refs.props?.onPressIn?.(event);
            state.interaction.active.set(true);
        };
        props.onPressOut = (event) => {
            state.refs.props?.onPressOut?.(event);
            state.interaction.active.set(false);
        };
    }
    if (state.interaction.hover || isContainer) {
        state.interaction.hover ??= (0, observable_1.observable)(false);
        props.onHoverIn = (event) => {
            state.refs.props?.onHoverIn?.(event);
            state.interaction.hover.set(true);
        };
        props.onHoverOut = (event) => {
            state.refs.props?.onHoverOut?.(event);
            state.interaction.hover.set(false);
        };
    }
    if (state.interaction.focus || isContainer) {
        state.interaction.focus ??= (0, observable_1.observable)(false);
        props.onFocus = (event) => {
            state.refs.props?.onFocus?.(event);
            state.interaction.focus.set(true);
        };
        props.onBlur = (event) => {
            state.refs.props?.onBlur?.(event);
            state.interaction.focus.set(false);
        };
    }
    if (state.interaction.active ||
        state.interaction.hover ||
        state.interaction.focus) {
        props.onPress = (event) => {
            state.refs.props?.onPress?.(event);
        };
    }
    if (state.interaction.layout || isContainer) {
        state.interaction.layout ??= (0, observable_1.observable)([0, 0]);
        props.onLayout = (event) => {
            state.refs.props?.onLayout?.(event);
            const layout = event.nativeEvent.layout;
            const prevLayout = state.interaction.layout.get();
            if (layout.width !== prevLayout[0] || layout.height !== prevLayout[0]) {
                state.interaction.layout.set([layout.width, layout.height]);
            }
        };
    }
    if (component === react_native_1.View &&
        (state.interaction.hover ||
            state.interaction.active ||
            state.interaction.focus)) {
        component = react_native_1.Pressable;
        props.cssInterop = false;
        if (shouldWarn &&
            state.upgrades.pressable === exports.UpgradeState.SHOULD_UPGRADE) {
            printUpgradeWarning(`Converting View to Pressable should only happen during the initial render otherwise it will remount the View.\n\nTo prevent this warning avoid adding styles which use pseudo-classes (e.g :hover, :active, :focus) to View components after the initial render, or change the View to a Pressable`, state.refs.props);
        }
        state.upgrades.pressable = exports.UpgradeState.UPGRADED;
    }
    if (state.upgrades.animated) {
        if (shouldWarn && state.upgrades.animated === exports.UpgradeState.SHOULD_UPGRADE) {
            printUpgradeWarning(`Converting component to animated component should only happen during the initial render otherwise it will remount the component.\n\nTo prevent this warning avoid dynamically adding animation/transition styles to components after the initial render, or add a default style that sets "animation: none", "transition-property: none"`, state.refs.props);
        }
        state.upgrades.animated = exports.UpgradeState.UPGRADED;
        component = createAnimatedComponent(component);
    }
    if (state.upgrades.variables) {
        if (shouldWarn &&
            state.upgrades.variables === exports.UpgradeState.SHOULD_UPGRADE) {
            printUpgradeWarning(`Making a component inheritable should only happen during the initial render otherwise it will remount the component.\n\nTo prevent this warning avoid dynamically adding CSS variables or 'container' styles to components after the initial render, or ensure it has a default style that sets either a CSS variable, "container: none" or "container-type: none"`, state.refs.props);
        }
        state.upgrades.variables = exports.UpgradeState.UPGRADED;
        props = {
            value: variables,
            children: (0, react_1.createElement)(component, props),
        };
        component = globals_1.variableContext.Provider;
    }
    if (state.upgrades.containers) {
        if (shouldWarn &&
            state.upgrades.containers === exports.UpgradeState.SHOULD_UPGRADE) {
            printUpgradeWarning(`Making a component inheritable should only happen during the initial render otherwise it will remount the component.\n\nTo prevent this warning avoid dynamically adding CSS variables or 'container' styles to components after the initial render, or ensure it has a default style that sets either a CSS variable, "container: none" or "container-type: none"`, state.refs.props);
        }
        state.upgrades.containers = exports.UpgradeState.UPGRADED;
        props = {
            value: containers,
            children: (0, react_1.createElement)(component, props),
        };
        component = globals_1.containerContext.Provider;
    }
    state.upgrades.canWarn = process.env.NODE_ENV !== "production";
    if (component === baseComponent) {
        switch ((0, utils_1.getComponentType)(component)) {
            case "forwardRef": {
                const ref = props.ref;
                delete props.ref;
                return component.render(props, ref);
            }
            case "function":
                return component(props);
            case "string":
            case "object":
            case "class":
            case "unknown":
                return (0, react_1.createElement)(component, props);
        }
    }
    else {
        return (0, react_1.createElement)(component, props);
    }
}
exports.renderComponent = renderComponent;
function createAnimatedComponent(Component) {
    if (animatedCache.has(Component)) {
        return animatedCache.get(Component);
    }
    else if (Component.displayName?.startsWith("AnimatedComponent")) {
        return Component;
    }
    if (!(typeof Component !== "function" ||
        (Component.prototype && Component.prototype.isReactComponent))) {
        throw new Error(`Looks like you're passing an animation style to a function component \`${Component.name}\`. Please wrap your function component with \`React.forwardRef()\` or use a class component instead.`);
    }
    const { default: Animated, useAnimatedStyle } = require("react-native-reanimated");
    let AnimatedComponent = Animated.createAnimatedComponent(Component);
    const CSSInteropAnimationWrapper = (0, react_1.forwardRef)((props, ref) => {
        const propStyle = props.style;
        const style = useAnimatedStyle(() => {
            const style = {};
            if (!propStyle)
                return style;
            for (const key of Object.keys(propStyle)) {
                const value = propStyle[key];
                if (typeof value === "object" && "_isReanimatedSharedValue" in value) {
                    style[key] = value.value;
                }
                else if (key === "transform") {
                    style.transform = value.map((v) => {
                        const [key, value] = Object.entries(v)[0];
                        if (typeof value === "object" && "value" in value) {
                            return { [key]: value.value };
                        }
                        else {
                            return { [key]: value };
                        }
                    });
                }
                else {
                    style[key] = value;
                }
            }
            return style;
        }, [propStyle]);
        return (0, react_1.createElement)(AnimatedComponent, {
            ...props,
            style,
            ref,
        });
    });
    CSSInteropAnimationWrapper.displayName = `CSSInteropAnimationWrapper(${Component.displayName ?? Component.name})`;
    animatedCache.set(Component, CSSInteropAnimationWrapper);
    return CSSInteropAnimationWrapper;
}
function printUpgradeWarning(warning, originalProps) {
    console.warn(`CssInterop upgrade warning.\n\n${warning}.\n\nIf add/removing sibling components cause this warning, add a unique "key" prop so React can correctly track this component.`);
    try {
        console.warn(`The previous warning was caused by a component with these props: ${JSON.stringify(originalProps)}`);
    }
    catch {
        if (originalProps) {
            console.warn(`The previous warning was caused by a component with these props: ${JSON.stringify(Object.keys(originalProps))}. Some props could not be stringified, so only the keys are shown.`);
        }
    }
}
//# sourceMappingURL=render-component.js.map