"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calc = exports.defaultValues = exports.getHeight = exports.getWidth = exports.setDeep = exports.getEasing = exports.timeToMS = exports.resolveTransitionValue = exports.resolveAnimation = exports.resolveValue = void 0;
const react_native_1 = require("react-native");
const globals_1 = require("./globals");
const observable_1 = require("../observable");
const shared_1 = require("../../shared");
function resolveValue(state, descriptor, style) {
    switch (typeof descriptor) {
        case "undefined":
            return;
        case "boolean":
        case "number":
        case "function":
            return descriptor;
        case "string":
            return descriptor.endsWith("px")
                ? parseInt(descriptor.slice(0, -2), 10)
                : descriptor;
    }
    if (Array.isArray(descriptor)) {
        return descriptor.map((v) => resolveValue(state, v, style));
    }
    switch (descriptor.name) {
        case "var": {
            const value = resolve(state, descriptor.arguments[0], style);
            if (typeof value === "string")
                return getVar(state, value, style);
        }
        case "calc": {
            return calc(state, descriptor.arguments, style);
        }
        case "vh": {
            const value = resolve(state, descriptor.arguments[0], style);
            const vhValue = globals_1.vh.get(state.styleEffect) / 100;
            if (typeof value === "number")
                return round(vhValue * value);
        }
        case "vw": {
            const value = resolve(state, descriptor.arguments[0], style);
            const vwValue = globals_1.vw.get(state.styleEffect) / 100;
            if (typeof value === "number")
                return round(vwValue * value);
        }
        case "em": {
            const value = resolve(state, descriptor.arguments[0], style);
            const fontSize = style?.fontSize ?? globals_1.rem.get(state.styleEffect);
            if (typeof value === "number")
                return round(fontSize * value);
        }
        case "rem": {
            const value = resolve(state, descriptor.arguments[0], style);
            const remValue = globals_1.rem.get(state.styleEffect);
            if (typeof value === "number")
                return round(remValue * value);
        }
        case "rnh": {
            const value = resolve(state, descriptor.arguments[0], style);
            const height = style?.height ?? getHeight(state);
            if (typeof value === "number")
                return round(height * value);
        }
        case "rnw": {
            const value = resolve(state, descriptor.arguments[0], style);
            const width = style?.width ?? getWidth(state);
            if (typeof value === "number")
                return round(width * value);
        }
        case "hwb":
            const args = resolve(state, descriptor.arguments, style).flat(10);
            return getColorArgs(args, { 3: "hwb" });
        case "rgb":
        case "rgba": {
            const args = resolve(state, descriptor.arguments, style).flat(10);
            return getColorArgs(args, { 3: "rgb", 4: "rgba" });
        }
        case "hsl":
        case "hsla": {
            const args = resolve(state, descriptor.arguments, style).flat(10);
            return getColorArgs(args, { 3: "hsl", 4: "hsla" });
        }
        case "hairlineWidth": {
            return react_native_1.StyleSheet.hairlineWidth;
        }
        case "platformColor": {
            return (0, react_native_1.PlatformColor)(...descriptor.arguments);
        }
        case "platformSelect": {
            return resolve(state, react_native_1.Platform.select(descriptor.arguments[0]), style);
        }
        case "getPixelSizeForLayoutSize": {
            const v = resolve(state, descriptor.arguments[0], style);
            if (typeof v === "number")
                return react_native_1.PixelRatio.getPixelSizeForLayoutSize(v);
        }
        case "fontScale": {
            const value = resolve(state, descriptor.arguments[0], style);
            if (typeof value === "number")
                return react_native_1.PixelRatio.getFontScale() * value;
        }
        case "pixelScale": {
            const value = resolve(state, descriptor.arguments[0], style);
            if (typeof value === "number")
                return react_native_1.PixelRatio.get() * value;
        }
        case "pixelScaleSelect": {
            const specifics = descriptor.arguments[0];
            return resolve(state, specifics[react_native_1.PixelRatio.get()] ?? specifics["default"], style);
        }
        case "fontScaleSelect": {
            const specifics = descriptor.arguments[0];
            return resolve(state, specifics[react_native_1.PixelRatio.getFontScale()] ?? specifics["default"], style);
        }
        case "roundToNearestPixel": {
            const v = resolve(state, descriptor.arguments[0], style);
            if (typeof v === "number")
                return react_native_1.PixelRatio.roundToNearestPixel(v);
        }
        default: {
            if ("name" in descriptor && "arguments" in descriptor) {
                const args = resolve(state, descriptor.arguments, style).join(",");
                return `${descriptor.name}(${args})`;
            }
            else {
                return descriptor;
            }
        }
    }
}
exports.resolveValue = resolveValue;
function resolve(state, args, style) {
    if (typeof args !== "object") {
        return args;
    }
    if (!Array.isArray(args)) {
        return "arguments" in args ? resolveValue(state, args, style) : args;
    }
    let resolved = [];
    for (let value of args) {
        value = resolve(state, value, style);
        if (value !== undefined) {
            resolved.push(value);
        }
    }
    return resolved;
}
function getVar(propState, name, style) {
    if (!name)
        return;
    let value = undefined;
    value ??= propState.variables?.[name];
    value ??= globals_1.universalVariables[name]?.get(propState.styleEffect);
    if (value === undefined) {
        value = propState.refs.variables[name];
        if (typeof value === "object" && "get" in value) {
            value = value.get(propState.styleEffect);
        }
        propState.variableTracking ??= new Map();
        propState.variableTracking.set(name, value);
    }
    return resolveValue(propState, value, style);
}
function resolveAnimation(state, [initialFrame, ...frames], property, props = {}, normalizedProps, delay, totalDuration, timingFunction) {
    const { withDelay, withTiming, Easing } = require("react-native-reanimated");
    const initialValue = resolveAnimationValue(state, props, normalizedProps, property, initialFrame.value);
    return [
        initialValue,
        ...frames.map((frame) => {
            return withDelay(delay, withTiming(resolveAnimationValue(state, props, normalizedProps, property, frame.value), {
                duration: totalDuration * frame.progress,
                easing: getEasing(timingFunction, Easing),
            }));
        }),
    ];
}
exports.resolveAnimation = resolveAnimation;
function resolveAnimationValue(state, props = {}, normalizedProps, property, value) {
    if (value === "!INHERIT!") {
        value = normalizedProps[property] ?? props.style[property];
        if (value === undefined) {
            const defaultValueFn = exports.defaultValues[property];
            return typeof defaultValueFn === "function"
                ? defaultValueFn(state.styleEffect)
                : defaultValueFn;
        }
        return value;
    }
    else {
        return resolve(state, value, props);
    }
}
function resolveTransitionValue(state, props = {}, normalizedProps, property) {
    const defaultValueFn = exports.defaultValues[property];
    const defaultValue = typeof defaultValueFn === "function"
        ? defaultValueFn(state.styleEffect)
        : defaultValueFn;
    return {
        defaultValue,
        value: normalizedProps[property] ?? props[state.target]?.[property],
    };
}
exports.resolveTransitionValue = resolveTransitionValue;
const timeToMS = (time) => {
    return time.type === "milliseconds" ? time.value : time.value * 1000;
};
exports.timeToMS = timeToMS;
function round(number) {
    return Math.round((number + Number.EPSILON) * 100) / 100;
}
function getEasing(timingFunction, Easing) {
    switch (timingFunction.type) {
        case "ease":
            return Easing.ease;
        case "ease-in":
            return Easing.in(Easing.quad);
        case "ease-out":
            return Easing.out(Easing.quad);
        case "ease-in-out":
            return Easing.inOut(Easing.quad);
        case "linear":
            return Easing.linear;
        case "cubic-bezier":
            return Easing.bezier(timingFunction.x1, timingFunction.y1, timingFunction.x2, timingFunction.y2);
        default:
            return Easing.linear;
    }
}
exports.getEasing = getEasing;
function setDeep(target, paths, value) {
    const prop = paths[paths.length - 1];
    for (let i = 0; i < paths.length - 1; i++) {
        const token = paths[i];
        target[token] ??= {};
        target = target[token];
    }
    if (shared_1.transformKeys.has(prop)) {
        if (target.transform) {
            const existing = target.transform.find((t) => Object.keys(t)[0] === prop);
            if (existing) {
                existing[prop] = value;
            }
            else {
                target.transform.push({ [prop]: value });
            }
        }
        else {
            target.transform ??= [];
            target.transform.push({ [prop]: value });
        }
    }
    else {
        target[prop] = value;
    }
}
exports.setDeep = setDeep;
function getColorArgs(args, config) {
    if (config[args.length])
        return `${config[args.length]}(${args.join(", ")})`;
    args = args.flatMap((arg) => {
        return typeof arg === "string"
            ? arg.split(/[,\s\/]/g).filter(Boolean)
            : arg;
    });
    if (config[args.length])
        return `${config[args.length]}(${args.join(", ")})`;
}
function getLayout(state, interaction = state.interaction) {
    interaction.layout ??= (0, observable_1.observable)([0, 0]);
    return interaction.layout.get(state.styleEffect);
}
function getWidth(state) {
    return getLayout(state)[0];
}
exports.getWidth = getWidth;
function getHeight(state) {
    return getLayout(state)[1];
}
exports.getHeight = getHeight;
exports.defaultValues = {
    backgroundColor: "transparent",
    borderBottomColor: "transparent",
    borderBottomLeftRadius: 0,
    borderBottomRightRadius: 0,
    borderBottomWidth: 0,
    borderColor: "transparent",
    borderLeftColor: "transparent",
    borderLeftWidth: 0,
    borderRadius: 0,
    borderRightColor: "transparent",
    borderRightWidth: 0,
    borderTopColor: "transparent",
    borderTopWidth: 0,
    borderWidth: 0,
    bottom: 0,
    color: (effect) => {
        return globals_1.systemColorScheme.get(effect) === "dark" ? "white" : "black";
    },
    flex: 1,
    flexBasis: 1,
    flexGrow: 1,
    flexShrink: 0,
    fontSize: 14,
    fontWeight: "400",
    gap: 0,
    left: 0,
    lineHeight: 14,
    margin: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    marginTop: 0,
    maxHeight: 99999,
    maxWidth: 99999,
    minHeight: 0,
    minWidth: 0,
    opacity: 1,
    padding: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    perspective: 1,
    right: 0,
    rotate: "0deg",
    rotateX: "0deg",
    rotateY: "0deg",
    rotateZ: "0deg",
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    skewX: "0deg",
    skewY: "0deg",
    top: 0,
    translateX: 0,
    translateY: 0,
    zIndex: 0,
};
const calcPrecedence = {
    "+": 1,
    "-": 1,
    "*": 2,
    "/": 2,
};
function applyCalcOperator(operator, b, a, values) {
    switch (operator) {
        case "+":
            return values.push(a + b);
        case "-":
            return values.push(a - b);
        case "*":
            return values.push(a * b);
        case "/":
            return values.push(a / b);
    }
}
function calc(state, expression, style) {
    const values = [];
    const ops = [];
    let mode;
    for (let token of expression) {
        switch (typeof token) {
            case "undefined":
                return;
            case "number":
                if (!mode)
                    mode = "number";
                if (mode !== "number")
                    return;
                values.push(token);
                continue;
            case "object": {
                const value = resolveValue(state, token, style);
                switch (typeof value) {
                    case "number": {
                        if (!mode)
                            mode = "number";
                        if (mode !== "number")
                            return;
                        values.push(value);
                        continue;
                    }
                    case "string": {
                        if (!value.endsWith("%")) {
                            return;
                        }
                        if (!mode)
                            mode = "percentage";
                        if (mode !== "percentage")
                            return;
                        values.push(Number.parseFloat(value.slice(0, -1)));
                        continue;
                    }
                    default:
                        return;
                }
            }
            case "string": {
                if (token === "(") {
                    ops.push(token);
                }
                else if (token === ")") {
                    while (ops.length && ops[ops.length - 1] !== "(") {
                        applyCalcOperator(ops.pop(), values.pop(), values.pop(), values);
                    }
                    ops.pop();
                }
                else if (token.endsWith("%")) {
                    if (!mode)
                        mode = "percentage";
                    if (mode !== "percentage")
                        return;
                    values.push(Number.parseFloat(token.slice(0, -1)));
                }
                else {
                    while (ops.length &&
                        calcPrecedence[ops[ops.length - 1]] >= calcPrecedence[token]) {
                        applyCalcOperator(ops.pop(), values.pop(), values.pop(), values);
                    }
                    ops.push(token);
                }
            }
        }
    }
    while (ops.length) {
        applyCalcOperator(ops.pop(), values.pop(), values.pop(), values);
    }
    if (!mode)
        return;
    const value = round(values[0]);
    return mode === "percentage" ? `${value}%` : value;
}
exports.calc = calc;
//# sourceMappingURL=resolve-value.js.map