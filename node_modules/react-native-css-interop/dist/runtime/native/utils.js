"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComponentType = exports.nativeStyleToProp = exports.retainSharedValues = exports.processTransition = exports.processAnimations = exports.processDeclarations = void 0;
const render_component_1 = require("./render-component");
const resolve_value_1 = require("./resolve-value");
const stylesheet_1 = require("./stylesheet");
function processDeclarations(propState, declarations, props, normalizedProps, delayedValues) {
    if (!declarations)
        return;
    for (const declaration of declarations) {
        if (Array.isArray(declaration)) {
            if (declaration.length === 2) {
                const prop = declaration[0] === "style" ? propState.target : declaration[0];
                if (typeof declaration[1] === "object") {
                    props[prop] ??= {};
                    Object.assign(props[prop], declaration[1]);
                }
                else {
                    props[prop] = declaration[1];
                }
            }
            else {
                const paths = [...declaration[1]];
                if (propState.target !== "style" && paths[0] === "style") {
                    paths[0] = propState.target;
                }
                if (typeof declaration[2] === "object" && declaration[2].delay) {
                    const uniqueValue = {};
                    normalizedProps[declaration[0]] = uniqueValue;
                    delayedValues.push(() => {
                        if (normalizedProps[declaration[0]] !== uniqueValue) {
                            return;
                        }
                        const value = (0, resolve_value_1.resolveValue)(propState, declaration[2], props[propState.target]);
                        (0, resolve_value_1.setDeep)(props, paths, value);
                        normalizedProps[declaration[0]] = value;
                    });
                }
                else {
                    const value = (0, resolve_value_1.resolveValue)(propState, declaration[2], props[propState.target]);
                    (0, resolve_value_1.setDeep)(props, paths, value);
                    normalizedProps[declaration[0]] = value;
                }
            }
        }
        else {
            if (typeof props[propState.target] === "object") {
                Object.assign(props[propState.target], declaration);
            }
            else {
                props[propState.target] = { ...declaration };
            }
        }
    }
}
exports.processDeclarations = processDeclarations;
function processAnimations(props, normalizedProps, seenAnimatedProps, propState) {
    if (!propState.animation)
        return;
    propState.sharedValues ??= new Map();
    propState.animationNames ??= new Set();
    const { name: animationNames, duration: durations, delay: delays, iterationCount: iterationCounts, timingFunction: easingFuncs, waitingLayout, } = propState.animation;
    const { makeMutable, withRepeat, withSequence } = require("react-native-reanimated");
    props.style ??= {};
    let names = [];
    let shouldResetAnimations = waitingLayout;
    for (const name of animationNames) {
        if (name.type === "none") {
            names = [];
            propState.animationNames.clear();
            break;
        }
        names.push(name.value);
        if (propState.animationNames.size === 0 ||
            !propState.animationNames.has(name.value)) {
            shouldResetAnimations = true;
        }
    }
    if (shouldResetAnimations) {
        propState.animationNames.clear();
        propState.animation.waitingLayout = false;
        for (let index = names.length - 1; index >= 0; index--) {
            const name = names[index % names.length];
            propState.animationNames.add(name);
            const animation = stylesheet_1.animationMap.get(name);
            if (!animation) {
                continue;
            }
            const totalDuration = (0, resolve_value_1.timeToMS)(durations[index % name.length]);
            const delay = (0, resolve_value_1.timeToMS)(delays[index % delays.length]);
            const easingFunction = easingFuncs[index % easingFuncs.length];
            const iterations = iterationCounts[index % iterationCounts.length];
            for (const frame of animation.frames) {
                const animationKey = frame[0];
                const valueFrames = frame[1].values;
                const pathTokens = frame[1].pathTokens;
                if (seenAnimatedProps.has(animationKey))
                    continue;
                seenAnimatedProps.add(animationKey);
                const [initialValue, ...sequence] = (0, resolve_value_1.resolveAnimation)(propState, valueFrames, animationKey, props, normalizedProps, delay, totalDuration, easingFunction);
                if (animation.requiresLayoutWidth || animation.requiresLayoutHeight) {
                    const needWidth = animation.requiresLayoutWidth &&
                        props.style?.width === undefined &&
                        (0, resolve_value_1.getWidth)(propState) === 0;
                    const needHeight = animation.requiresLayoutHeight &&
                        props.style?.height === undefined &&
                        (0, resolve_value_1.getHeight)(propState) === 0;
                    if (needWidth || needHeight) {
                        propState.animation.waitingLayout = true;
                    }
                }
                let sharedValue = propState.sharedValues.get(animationKey);
                if (!sharedValue) {
                    sharedValue = makeMutable(initialValue);
                    propState.sharedValues.set(animationKey, sharedValue);
                }
                else {
                    sharedValue.value = initialValue;
                }
                sharedValue.value = withRepeat(withSequence(...sequence), iterations.type === "infinite" ? -1 : iterations.value);
                (0, resolve_value_1.setDeep)(props, pathTokens, sharedValue);
            }
        }
    }
    else {
        for (const name of names) {
            const keyframes = stylesheet_1.animationMap.get(name);
            if (!keyframes)
                continue;
            props[propState.target] ??= {};
            for (const [animationKey, { pathTokens }] of keyframes.frames) {
                (0, resolve_value_1.setDeep)(props, pathTokens, propState.sharedValues.get(animationKey));
                seenAnimatedProps.add(animationKey);
            }
        }
    }
}
exports.processAnimations = processAnimations;
function processTransition(props, normalizedProps, seenAnimatedProps, propState) {
    if (!propState.transition)
        return;
    propState.sharedValues ??= new Map();
    const { property: properties, duration: durations, delay: delays, timingFunction: timingFunctions, } = propState.transition;
    const { makeMutable, withDelay, withTiming, Easing } = require("react-native-reanimated");
    if (!properties.includes("none")) {
        for (let index = 0; index < properties.length; index++) {
            const property = properties[index];
            if (seenAnimatedProps.has(property))
                continue;
            let sharedValue = propState.sharedValues.get(property);
            let { value, defaultValue } = (0, resolve_value_1.resolveTransitionValue)(propState, props, normalizedProps, property);
            if (value === undefined && !sharedValue) {
                continue;
            }
            else if (!sharedValue) {
                const initialValue = Number(propState.upgrades.animated) < render_component_1.UpgradeState.UPGRADED &&
                    value !== undefined
                    ? value
                    : defaultValue;
                sharedValue = makeMutable(initialValue);
                propState.sharedValues.set(property, sharedValue);
            }
            else if (value === undefined) {
                value = defaultValue;
            }
            seenAnimatedProps.add(property);
            const duration = (0, resolve_value_1.timeToMS)(durations[index % durations.length]);
            const delay = (0, resolve_value_1.timeToMS)(delays[index % delays.length]);
            const easing = timingFunctions[index % timingFunctions.length];
            if (value !== sharedValue.value) {
                sharedValue.value = withDelay(delay, withTiming(value, {
                    duration,
                    easing: (0, resolve_value_1.getEasing)(easing, Easing),
                }));
            }
            props.style ??= {};
            (0, resolve_value_1.setDeep)(props.style, [property], sharedValue);
        }
    }
}
exports.processTransition = processTransition;
function retainSharedValues(props, normalizedProps, seenAnimatedProps, propState) {
    if (!propState.sharedValues?.size)
        return;
    for (const entry of propState.sharedValues) {
        if (seenAnimatedProps.has(entry[0]))
            continue;
        let value = props.style?.[entry[0]] ??
            normalizedProps[entry[0]] ??
            resolve_value_1.defaultValues[entry[0]];
        if (typeof value === "function") {
            value = value(propState.styleEffect);
        }
        entry[1].value = value;
        props.style?.[entry[0]] ??
            normalizedProps[entry[0]] ??
            resolve_value_1.defaultValues[entry[0]];
        (0, resolve_value_1.setDeep)(props.style, [entry[0]], entry[1]);
    }
}
exports.retainSharedValues = retainSharedValues;
function nativeStyleToProp(props, config) {
    if (config.target !== "style" || !config.nativeStyleToProp)
        return;
    for (let move of Object.entries(config.nativeStyleToProp)) {
        const source = move[0];
        const sourceValue = props[config.target]?.[source];
        if (sourceValue === undefined)
            continue;
        const targetProp = move[1] === true ? move[0] : move[1];
        props[targetProp] = sourceValue;
        delete props[config.target][source];
    }
}
exports.nativeStyleToProp = nativeStyleToProp;
const ForwardRefSymbol = Symbol.for("react.forward_ref");
function getComponentType(component) {
    switch (typeof component) {
        case "function":
        case "object":
            return "$$typeof" in component && component.$$typeof === ForwardRefSymbol
                ? "forwardRef"
                : component.prototype?.isReactComponent
                    ? "class"
                    : typeof component;
        default:
            return "unknown";
    }
}
exports.getComponentType = getComponentType;
//# sourceMappingURL=utils.js.map