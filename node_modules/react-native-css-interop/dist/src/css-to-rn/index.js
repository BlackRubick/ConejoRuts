"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssToReactNativeRuntime = void 0;
const lightningcss_1 = require("lightningcss");
const parseDeclaration_1 = require("./parseDeclaration");
const shared_1 = require("../shared");
const normalize_selectors_1 = require("./normalize-selectors");
const optimize_rules_1 = require("./optimize-rules");
function cssToReactNativeRuntime(code, options = {}) {
    const grouping = options.grouping?.map((value) => {
        return typeof value === "string" ? new RegExp(value) : value;
    }) ?? [];
    const extractOptions = {
        darkMode: { type: "media" },
        rules: new Map(),
        keyframes: new Map(),
        rootVariables: {},
        universalVariables: {},
        flags: {},
        appearanceOrder: 1,
        ...options,
        grouping,
    };
    (0, lightningcss_1.transform)({
        filename: "style.css",
        code: typeof code === "string" ? Buffer.from(code) : code,
        visitor: {
            Rule(rule) {
                extractRule(rule, extractOptions);
                return [];
            },
        },
        customAtRules: {
            cssInterop: {
                prelude: "<custom-ident>+",
            },
            "rn-hoist": {
                prelude: "<custom-ident>+",
            },
            "rn-move": {
                prelude: "<custom-ident>+",
            },
        },
    });
    const rules = [];
    for (const [name, styles] of extractOptions.rules) {
        if (styles.length === 0)
            continue;
        const styleRuleSet = { $$type: "StyleRuleSet" };
        for (const { warnings, ...style } of styles) {
            if (style.specificity.I) {
                styleRuleSet.important ??= [];
                styleRuleSet.important.push(style);
            }
            else {
                styleRuleSet.normal ??= [];
                styleRuleSet.normal.push(style);
            }
            if (warnings) {
                styleRuleSet.warnings ??= [];
                styleRuleSet.warnings.push(...warnings);
            }
            if (style.variables)
                styleRuleSet.variables = true;
            if (style.container)
                styleRuleSet.container = true;
            if (style.animations)
                styleRuleSet.animation = true;
            if (style.transition)
                styleRuleSet.animation = true;
        }
        rules.push([name, styleRuleSet]);
    }
    return {
        $$compiled: true,
        rules: (0, optimize_rules_1.optimizeRules)(rules),
        keyframes: Array.from(extractOptions.keyframes.entries()),
        rootVariables: extractOptions.rootVariables,
        universalVariables: extractOptions.universalVariables,
        flags: extractOptions.flags,
        rem: extractOptions.rem,
    };
}
exports.cssToReactNativeRuntime = cssToReactNativeRuntime;
function extractRule(rule, extractOptions, partialStyle = {}) {
    switch (rule.type) {
        case "keyframes": {
            extractKeyFrames(rule.value, extractOptions);
            break;
        }
        case "container": {
            extractedContainer(rule.value, extractOptions);
            break;
        }
        case "media": {
            extractMedia(rule.value, extractOptions);
            break;
        }
        case "style": {
            if (rule.value.declarations) {
                for (const style of getExtractedStyles(rule.value.declarations, extractOptions, getRnMoveMapping(rule.value.rules))) {
                    setStyleForSelectorList({ ...partialStyle, ...style }, rule.value.selectors, extractOptions);
                }
                extractOptions.appearanceOrder++;
            }
            break;
        }
        case "custom": {
            if (rule.value && rule.value?.name === "cssInterop") {
                extractCSSInteropFlag(rule, extractOptions);
            }
        }
    }
}
function getRnMoveMapping(rules) {
    if (!rules)
        return {};
    const mapping = {};
    for (const rule of rules) {
        if (rule.type !== "custom" && rule.value.name !== "rn-move")
            continue;
        let [first, tokens] = rule.value.prelude.value.components.map((c) => c.value);
        if (tokens) {
            if (tokens.startsWith("-")) {
                tokens = tokens.replace("-", "");
                mapping[(0, normalize_selectors_1.toRNProperty)(first)] = tokens.split(".").map(normalize_selectors_1.toRNProperty);
            }
            else {
                mapping[(0, normalize_selectors_1.toRNProperty)(first)] = [
                    "style",
                    ...tokens.split(".").map(normalize_selectors_1.toRNProperty),
                ];
            }
        }
        else {
            if (first.startsWith("-")) {
                mapping["*"] = [(0, normalize_selectors_1.toRNProperty)(first.replace("-", ""))];
            }
            else {
                mapping["*"] = ["style", (0, normalize_selectors_1.toRNProperty)(first)];
            }
        }
    }
    return mapping;
}
function extractCSSInteropFlag(rule, extractOptions) {
    if (rule.value.prelude.value.components[0].value !== "set") {
        return;
    }
    const [_, name, type, ...other] = rule.value.prelude.value.components.map((c) => c.value);
    if (name === "darkMode") {
        let value;
        if (other.length === 0 || other[0] === "media") {
            extractOptions.darkMode = { type: "media" };
        }
        else {
            value = other[0];
            if (value.startsWith(".")) {
                value = value.slice(1);
                extractOptions.darkMode = { type: "class", value };
            }
            else if (value.startsWith("[")) {
                extractOptions.darkMode = { type: "attribute", value };
            }
            else if (value === "dark") {
                extractOptions.darkMode = { type: "class", value };
            }
        }
        extractOptions.flags.darkMode = `${type} ${value}`.trim();
    }
    else {
        const value = other.length === 0 ? "true" : other;
        extractOptions.flags[name] = value;
    }
}
function extractMedia(mediaRule, extractOptions) {
    const media = [];
    for (const mediaQuery of mediaRule.query.mediaQueries) {
        let isScreen = mediaQuery.mediaType !== "print";
        if (mediaQuery.qualifier === "not") {
            isScreen = !isScreen;
        }
        if (isScreen) {
            media.push(mediaQuery);
        }
    }
    if (media.length === 0) {
        return;
    }
    for (const rule of mediaRule.rules) {
        extractRule(rule, extractOptions, { media });
    }
}
function extractedContainer(containerRule, extractOptions) {
    for (const rule of containerRule.rules) {
        extractRule(rule, extractOptions, {
            containerQuery: [
                {
                    name: containerRule.name,
                    condition: containerRule.condition,
                },
            ],
        });
    }
}
function setStyleForSelectorList(extractedStyle, selectorList, options) {
    const { rules: declarations } = options;
    for (const selector of (0, normalize_selectors_1.normalizeSelectors)(extractedStyle, selectorList, options)) {
        const style = { ...extractedStyle };
        if (!style.declarations)
            continue;
        if (selector.type === "rootVariables" ||
            selector.type === "universalVariables") {
            const fontSizeDeclaration = style.declarations.findLast((declaration) => {
                if (Array.isArray(declaration)) {
                    return (declaration[0] === "fontSize" && typeof declaration[2] === "number");
                }
                else {
                    return "fontSize" in declaration;
                }
            });
            if (fontSizeDeclaration) {
                const rem = Array.isArray(fontSizeDeclaration)
                    ? fontSizeDeclaration[2]
                    : fontSizeDeclaration.fontSize;
                if (typeof rem === "number") {
                    options.rem = rem;
                }
            }
            if (!style.variables) {
                continue;
            }
            const { type, subtype } = selector;
            const record = (options[type] ??= {});
            for (const [name, value] of style.variables) {
                record[name] ??= {};
                record[name][subtype] = value;
            }
            continue;
        }
        else if (selector.type === "className") {
            const { className, groupClassName, pseudoClasses, groupPseudoClasses, darkMode, attrs, } = selector;
            const specificity = {
                ...extractedStyle.specificity,
                ...selector.specificity,
            };
            if (groupClassName) {
                addDeclaration(declarations, groupClassName, {
                    $$type: "StyleRule",
                    specificity,
                    attrs,
                    declarations: [],
                    container: {
                        names: [groupClassName],
                    },
                });
                style.containerQuery ??= [];
                style.containerQuery.push({
                    name: groupClassName,
                    pseudoClasses: groupPseudoClasses,
                });
            }
            if (darkMode) {
                style.media ??= [];
                style.media.push({
                    mediaType: "all",
                    condition: {
                        type: "feature",
                        value: {
                            type: "plain",
                            name: "prefers-color-scheme",
                            value: { type: "ident", value: "dark" },
                        },
                    },
                });
            }
            addDeclaration(declarations, className, {
                ...style,
                specificity,
                pseudoClasses,
                attrs,
            });
        }
    }
}
function addDeclaration(declarations, className, style) {
    const existing = declarations.get(className);
    if (existing) {
        existing.push(style);
    }
    else {
        declarations.set(className, [style]);
    }
}
function extractKeyFrames(keyframes, extractOptions) {
    const animation = { frames: [] };
    const frames = {};
    let rawFrames = [];
    for (const frame of keyframes.keyframes) {
        if (!frame.declarations.declarations)
            continue;
        const { declarations: props } = declarationsToStyle(frame.declarations.declarations, {
            ...extractOptions,
            requiresLayout(name) {
                if (name === "rnw") {
                    animation.requiresLayoutWidth = true;
                }
                else {
                    animation.requiresLayoutHeight = true;
                }
            },
        }, {
            I: 99,
            S: 1,
            O: extractOptions.appearanceOrder,
        }, {});
        if (!props)
            continue;
        const values = props.filter((prop) => {
            const target = prop.length === 2 ? prop[0] : prop[1][0];
            return target === "style";
        });
        if (values.length === 0)
            continue;
        for (const selector of frame.selectors) {
            const keyframe = selector.type === "percentage"
                ? selector.value * 100
                : selector.type === "from"
                    ? 0
                    : selector.type === "to"
                        ? 100
                        : undefined;
            if (keyframe === undefined)
                continue;
            switch (selector.type) {
                case "percentage":
                    rawFrames.push({ selector: selector.value, values });
                    break;
                case "from":
                    rawFrames.push({ selector: 0, values });
                    break;
                case "to":
                    rawFrames.push({ selector: 1, values });
                    break;
                default:
                    selector;
            }
        }
    }
    rawFrames = rawFrames.sort((a, b) => a.selector - b.selector);
    for (let i = 0; i < rawFrames.length; i++) {
        const rawFrame = rawFrames[i];
        const animationProgress = rawFrame.selector;
        const previousProgress = i === 0 ? 0 : rawFrames[i - 1].selector;
        const progress = animationProgress - previousProgress;
        for (const frameValue of rawFrame.values) {
            if (frameValue.length === 2)
                continue;
            const [key, pathTokens, value] = frameValue;
            if (progress === 0) {
                frames[key] = {
                    values: [{ value, progress }],
                    pathTokens,
                };
            }
            else {
                frames[key] ??= {
                    values: [{ value: "!INHERIT!", progress: 0 }],
                    pathTokens,
                };
                frames[key].values.push({ value, progress });
            }
        }
    }
    animation.frames = Object.entries(frames);
    extractOptions.keyframes.set(keyframes.name.value, animation);
}
function getExtractedStyles(declarationBlock, options, mapping = {}) {
    const extractedStyles = [];
    if (declarationBlock.declarations && declarationBlock.declarations.length) {
        extractedStyles.push(declarationsToStyle(declarationBlock.declarations, options, {
            I: 0,
            S: 1,
            O: options.appearanceOrder,
        }, mapping));
    }
    if (declarationBlock.importantDeclarations &&
        declarationBlock.importantDeclarations.length) {
        extractedStyles.push(declarationsToStyle(declarationBlock.importantDeclarations, options, {
            I: 1,
            S: 1,
            O: options.appearanceOrder,
        }, mapping));
    }
    return extractedStyles;
}
function declarationsToStyle(declarations, options, specificity, mapping) {
    const props = [];
    const extractedStyle = {
        $$type: "StyleRule",
        specificity: { A: 0, B: 0, C: 0, ...specificity },
        declarations: props,
    };
    function addStyleProp(attribute, value, moveTokens) {
        if (value === undefined) {
            return;
        }
        if (attribute.startsWith("--")) {
            return addVariable(attribute, value);
        }
        attribute = (0, normalize_selectors_1.toRNProperty)(attribute);
        let pathTokens = mapping[attribute] ?? mapping["*"] ?? ["style", attribute];
        if (moveTokens) {
            pathTokens = [...pathTokens.slice(0, -1), ...moveTokens];
        }
        props.push([attribute, pathTokens, value]);
    }
    function addTransformProp(property, value) {
        return addStyleProp(property, value);
    }
    function handleTransformShorthand(name, options) {
        if (allEqual(...Object.values(options))) {
            return addStyleProp(name, Object.values(options)[0], ["transform", name]);
        }
        else {
            for (const [name, value] of Object.entries(options)) {
                addStyleProp(name, value, ["transform", name]);
            }
        }
    }
    function handleStyleShorthand(name, options) {
        if (allEqual(...Object.values(options))) {
            return addStyleProp(name, Object.values(options)[0]);
        }
        else {
            for (const [name, value] of Object.entries(options)) {
                addStyleProp(name, value);
            }
        }
    }
    function addVariable(property, value) {
        extractedStyle.variables ??= [];
        extractedStyle.variables.push([property, value]);
    }
    function addContainerProp(declaration) {
        let names = [shared_1.DEFAULT_CONTAINER_NAME];
        let type;
        switch (declaration.property) {
            case "container":
                if (declaration.value.name.type === "none") {
                    names = false;
                }
                else {
                    names = declaration.value.name.value;
                }
                type = declaration.value.containerType;
                break;
            case "container-name":
                if (declaration.value.type === "none") {
                    names = false;
                }
                else {
                    names = declaration.value.value;
                }
                break;
            case "container-type":
                type = declaration.value;
                break;
        }
        extractedStyle.container ??= {};
        if (names === false) {
            extractedStyle.container.names = false;
        }
        else if (Array.isArray(extractedStyle.container.names)) {
            extractedStyle.container.names = [
                ...new Set([...extractedStyle.container.names, ...names]),
            ];
        }
        else {
            extractedStyle.container.names = names;
        }
        if (type) {
            extractedStyle.container ??= {};
            extractedStyle.container.type = type;
        }
    }
    function addTransitionProp(declaration) {
        extractedStyle.transition ??= {};
        switch (declaration.property) {
            case "transition-property":
                extractedStyle.transition.property = [];
                for (const v of declaration.value) {
                    extractedStyle.transition.property.push((0, normalize_selectors_1.toRNProperty)(v.property));
                }
                break;
            case "transition-duration":
                extractedStyle.transition.duration = declaration.value;
                break;
            case "transition-delay":
                extractedStyle.transition.delay = declaration.value;
                break;
            case "transition-timing-function":
                extractedStyle.transition.timingFunction = declaration.value;
                break;
            case "transition": {
                let setProperty = true;
                let setDuration = true;
                let setDelay = true;
                let setTiming = true;
                if (extractedStyle.transition.property) {
                    setProperty = false;
                }
                else {
                    extractedStyle.transition.property = [];
                }
                if (extractedStyle.transition.duration) {
                    setDuration = false;
                }
                else {
                    extractedStyle.transition.duration = [];
                }
                if (extractedStyle.transition.delay) {
                    setDelay = false;
                }
                else {
                    extractedStyle.transition.delay = [];
                }
                if (extractedStyle.transition.timingFunction) {
                    setTiming = false;
                }
                else {
                    extractedStyle.transition.timingFunction = [];
                }
                for (const value of declaration.value) {
                    if (setProperty) {
                        extractedStyle.transition.property?.push((0, normalize_selectors_1.toRNProperty)(value.property.property));
                    }
                    if (setDuration) {
                        extractedStyle.transition.duration?.push(value.duration);
                    }
                    if (setDelay) {
                        extractedStyle.transition.delay?.push(value.delay);
                    }
                    if (setTiming) {
                        extractedStyle.transition.timingFunction?.push(value.timingFunction);
                    }
                }
                break;
            }
        }
    }
    function addAnimationProp(property, value) {
        if (property === "animation") {
            const groupedProperties = {};
            for (const animation of value) {
                for (const [key, value] of Object.entries(animation)) {
                    groupedProperties[key] ??= [];
                    groupedProperties[key].push(value);
                }
            }
            extractedStyle.animations ??= {};
            for (const [property, value] of Object.entries(groupedProperties)) {
                const key = property
                    .replace("animation-", "")
                    .replace(/-./g, (x) => x[1].toUpperCase());
                extractedStyle.animations[key] ??= value;
            }
        }
        else {
            const key = property
                .replace("animation-", "")
                .replace(/-./g, (x) => x[1].toUpperCase());
            extractedStyle.animations ??= {};
            extractedStyle.animations[key] = value;
        }
    }
    function addWarning(warning) {
        const warningRegexArray = options.ignorePropertyWarningRegex;
        if (warningRegexArray) {
            const match = warningRegexArray.some((regex) => new RegExp(regex).test(warning.property));
            if (match)
                return;
        }
        extractedStyle.warnings ??= [];
        extractedStyle.warnings.push(warning);
    }
    function requiresLayout(name) {
        if (name === "rnw") {
            extractedStyle.requiresLayoutWidth = true;
        }
        else {
            extractedStyle.requiresLayoutHeight = true;
        }
    }
    const parseDeclarationOptions = {
        addStyleProp,
        addTransformProp,
        handleStyleShorthand,
        handleTransformShorthand,
        addAnimationProp,
        addContainerProp,
        addTransitionProp,
        requiresLayout,
        addWarning,
        ...options,
    };
    for (const declaration of declarations) {
        (0, parseDeclaration_1.parseDeclaration)(declaration, parseDeclarationOptions);
    }
    return extractedStyle;
}
function allEqual(...params) {
    return params.every((param, index, array) => {
        return index === 0 ? true : equal(array[0], param);
    });
}
function equal(a, b) {
    if (a === b)
        return true;
    if (typeof a !== typeof b)
        return false;
    if (a === null || b === null)
        return false;
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            if (!equal(a[i], b[i]))
                return false;
        }
        return true;
    }
    if (typeof a === "object" && typeof b === "object") {
        if (Object.keys(a).length !== Object.keys(b).length)
            return false;
        for (const key in a) {
            if (!equal(a[key], b[key]))
                return false;
        }
        return true;
    }
    return false;
}
//# sourceMappingURL=index.js.map