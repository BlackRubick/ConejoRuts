"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeRules = void 0;
const shared_1 = require("../shared");
function optimizeRules(rules) {
    return rules?.map(([name, ruleSet]) => {
        let isDynamic = ruleSet.important && ruleSet.important?.length > 0;
        if (isDynamic) {
            return [name, ruleSet];
        }
        if (ruleSet.normal) {
            for (const rule of ruleSet.normal) {
                if (!("declarations" in rule) || Object.keys(rules).length > 2) {
                    continue;
                }
                rule.declarations = mergeStaticDeclarations(rule.declarations);
            }
        }
        return [name, ruleSet];
    });
}
exports.optimizeRules = optimizeRules;
function mergeStaticDeclarations(declarations) {
    if (!declarations) {
        return;
    }
    const merged = {};
    const newDeclarations = [];
    for (const declaration of declarations) {
        if (declaration.length === 2)
            continue;
        const [, pathTokens, value] = declaration;
        if (typeof value === "object") {
            let shouldBeDelayed = value.delay;
            if (!shouldBeDelayed && "arguments" in value) {
                shouldBeDelayed = value.arguments.some(shouldValueBeDelayed);
            }
            if (shouldBeDelayed) {
                value.delay = true;
            }
            newDeclarations.push(declaration);
            continue;
        }
        if (pathTokens.length !== 2) {
            newDeclarations.push(declaration);
            continue;
        }
        const [path, prop] = pathTokens;
        if (shared_1.transformKeys.has(prop)) {
            newDeclarations.push(declaration);
            continue;
        }
        merged[path] ??= {};
        merged[path][prop] = value;
    }
    if (Object.keys(merged).length > 0) {
        newDeclarations.push(...Object.entries(merged));
    }
    return newDeclarations;
}
function shouldValueBeDelayed(value) {
    if (typeof value !== "object" || !value) {
        return false;
    }
    if (Array.isArray(value)) {
        return value.some(shouldValueBeDelayed);
    }
    if (dynamicNames.has(value.name)) {
        return true;
    }
    if (value.delay) {
        return true;
    }
    if ("arguments" in value) {
        return value.arguments.some(shouldValueBeDelayed);
    }
    return value;
}
const dynamicNames = new Set(["vw"]);
//# sourceMappingURL=optimize-rules.js.map